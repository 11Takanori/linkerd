package io.buoyant.router

import com.twitter.finagle.{Mux => FinagleMux, _}
import com.twitter.finagle.buoyant._
import com.twitter.finagle.client.StackClient
import com.twitter.finagle.mux.{Request, Response}
import com.twitter.finagle.param.ProtocolLibrary
import com.twitter.finagle.server.StackServer
import com.twitter.util._
import java.net.SocketAddress

object Mux extends Router[Request, Response] with Server[Request, Response] {

  object Router {
    val pathStack: Stack[ServiceFactory[Request, Response]] =
      StackRouter.newPathStack[Request, Response]

    val boundStack: Stack[ServiceFactory[Request, Response]] =
      StackRouter.newBoundStack[Request, Response]
        .replace(MuxEncodeResidual.role, MuxEncodeResidual)

    val client: StackClient[Request, Response] =
      FinagleMux.client
        .transformed(StackRouter.Client.mkStack(_))

    val defaultParams: Stack.Params =
      StackRouter.defaultParams +
        ProtocolLibrary("mux")

    class Identifier(
      prefix: Path = Path.empty,
      dtab: () => Dtab = () => Dtab.base
    ) extends RoutingFactory.Identifier[Request] {
      def apply(req: Request): Future[Dst] =
        Future.value(Dst.Path(prefix ++ req.destination, dtab(), Dtab.local))
    }

  }

  case class Router(
    pathStack: Stack[ServiceFactory[Request, Response]] = Router.pathStack,
    boundStack: Stack[ServiceFactory[Request, Response]] = Router.boundStack,
    client: StackClient[Request, Response] = Router.client,
    params: Stack.Params = Router.defaultParams
  ) extends StdStackRouter[Request, Response, Router] {
    protected def copy1(
      pathStack: Stack[ServiceFactory[Request, Response]] = this.pathStack,
      boundStack: Stack[ServiceFactory[Request, Response]] = this.boundStack,
      client: StackClient[Request, Response] = this.client,
      params: Stack.Params = this.params
    ): Router = copy(pathStack, boundStack, client, params)

    protected def newIdentifier(): RoutingFactory.Identifier[Request] = {
      val RoutingFactory.DstPrefix(pfx) = params[RoutingFactory.DstPrefix]
      val RoutingFactory.BaseDtab(baseDtab) = params[RoutingFactory.BaseDtab]
      new Router.Identifier(pfx, baseDtab)
    }
  }

  val router = Router()
  def factory(): ServiceFactory[Request, Response] =
    router.factory()

  object Server {
    // The default mux stack does not have a trace initializer module
    // because trace initialization is performed as a matter of mux
    // context-passing (com.twitter.finagle.mux.Processor).
    //
    // This means that when a request enters the stack, we cannot
    // determine whether the request was received with a trace id or
    // if the server dispatcher generated a request id.
    //
    // For now, we just blindly re-allocate a trace id by injecting a
    // trace initializer at the top of the stack so that we can be
    // sure we're not using a trace id generated by an upstream
    // router.  This approach may not work if annotations are emitted
    // before the MuxTraceInitializer filter is invoked.
    val stack: Stack[ServiceFactory[Request, Response]] =
      MuxTraceInitializer.server +: FinagleMux.server.stack

    val defaultParams: Stack.Params =
      StackServer.defaultParams +
        ProtocolLibrary("mux")
  }

  val server = FinagleMux.Server(Server.stack, Server.defaultParams)

  def serve(
    addr: SocketAddress,
    factory: ServiceFactory[Request, Response]
  ): ListeningServer = server.serve(addr, factory)

}
